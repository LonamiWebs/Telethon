"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
import os
import struct


class AffectedHistory(TLObject):
    CONSTRUCTOR_ID = 0xb45c69d1
    SUBCLASS_OF_ID = 0x2c49c116

    def __init__(self, pts, pts_count, offset):
        """
        :param int pts:
        :param int pts_count:
        :param int offset:

        Constructor for messages.AffectedHistory: Instance of AffectedHistory.
        """
        super().__init__()

        self.pts = pts
        self.pts_count = pts_count
        self.offset = offset

    def to_dict(self):
        return {
            '_': 'AffectedHistory',
            'pts': self.pts,
            'pts_count': self.pts_count,
            'offset': self.offset
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1i\\\xb4',
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            struct.pack('<i', self.offset),
        ))

    @staticmethod
    def from_reader(reader):
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _offset = reader.read_int()
        return AffectedHistory(pts=_pts, pts_count=_pts_count, offset=_offset)


class AffectedMessages(TLObject):
    CONSTRUCTOR_ID = 0x84d19185
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, pts, pts_count):
        """
        :param int pts:
        :param int pts_count:

        Constructor for messages.AffectedMessages: Instance of AffectedMessages.
        """
        super().__init__()

        self.pts = pts
        self.pts_count = pts_count

    def to_dict(self):
        return {
            '_': 'AffectedMessages',
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\x85\x91\xd1\x84',
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @staticmethod
    def from_reader(reader):
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return AffectedMessages(pts=_pts, pts_count=_pts_count)


class AllStickers(TLObject):
    CONSTRUCTOR_ID = 0xedfd405f
    SUBCLASS_OF_ID = 0x45834829

    def __init__(self, hash, sets):
        """
        :param int hash:
        :param list[StickerSet] sets:

        Constructor for messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        super().__init__()

        self.hash = hash
        self.sets = sets

    def to_dict(self):
        return {
            '_': 'AllStickers',
            'hash': self.hash,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]
        }

    def __bytes__(self):
        return b''.join((
            b'_@\xfd\xed',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return AllStickers(hash=_hash, sets=_sets)


class AllStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0xe86602c3
    SUBCLASS_OF_ID = 0x45834829

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'AllStickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\x02f\xe8',
        ))

    @staticmethod
    def from_reader(reader):
        return AllStickersNotModified()


class ArchivedStickers(TLObject):
    CONSTRUCTOR_ID = 0x4fcba9c8
    SUBCLASS_OF_ID = 0x7296d771

    def __init__(self, count, sets):
        """
        :param int count:
        :param list[StickerSetCovered] sets:

        Constructor for messages.ArchivedStickers: Instance of ArchivedStickers.
        """
        super().__init__()

        self.count = count
        self.sets = sets

    def to_dict(self):
        return {
            '_': 'ArchivedStickers',
            'count': self.count,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8\xa9\xcbO',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @staticmethod
    def from_reader(reader):
        _count = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return ArchivedStickers(count=_count, sets=_sets)


class BotCallbackAnswer(TLObject):
    CONSTRUCTOR_ID = 0x36585ea4
    SUBCLASS_OF_ID = 0x6c4dd18c

    def __init__(self, cache_time, alert=None, has_url=None, native_ui=None, message=None, url=None):
        """
        :param bool | None alert:
        :param bool | None has_url:
        :param bool | None native_ui:
        :param str | None message:
        :param str | None url:
        :param int cache_time:

        Constructor for messages.BotCallbackAnswer: Instance of BotCallbackAnswer.
        """
        super().__init__()

        self.alert = alert
        self.has_url = has_url
        self.native_ui = native_ui
        self.message = message
        self.url = url
        self.cache_time = cache_time

    def to_dict(self):
        return {
            '_': 'BotCallbackAnswer',
            'alert': self.alert,
            'has_url': self.has_url,
            'native_ui': self.native_ui,
            'message': self.message,
            'url': self.url,
            'cache_time': self.cache_time
        }

    def __bytes__(self):
        return b''.join((
            b'\xa4^X6',
            struct.pack('<I', (0 if self.alert is None or self.alert is False else 2) | (0 if self.has_url is None or self.has_url is False else 8) | (0 if self.native_ui is None or self.native_ui is False else 16) | (0 if self.message is None or self.message is False else 1) | (0 if self.url is None or self.url is False else 4)),
            b'' if self.message is None or self.message is False else (TLObject.serialize_bytes(self.message)),
            b'' if self.url is None or self.url is False else (TLObject.serialize_bytes(self.url)),
            struct.pack('<i', self.cache_time),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _alert = bool(flags & 2)
        _has_url = bool(flags & 8)
        _native_ui = bool(flags & 16)
        if flags & 1:
            _message = reader.tgread_string()
        else:
            _message = None
        if flags & 4:
            _url = reader.tgread_string()
        else:
            _url = None
        _cache_time = reader.read_int()
        return BotCallbackAnswer(cache_time=_cache_time, alert=_alert, has_url=_has_url, native_ui=_native_ui, message=_message, url=_url)


class BotResults(TLObject):
    CONSTRUCTOR_ID = 0x947ca848
    SUBCLASS_OF_ID = 0x3ed4d9c9

    def __init__(self, query_id, results, cache_time, users, gallery=None, next_offset=None, switch_pm=None):
        """
        :param bool | None gallery:
        :param int query_id:
        :param str | None next_offset:
        :param InlineBotSwitchPM | None switch_pm:
        :param list[BotInlineResult] results:
        :param int cache_time:
        :param list[User] users:

        Constructor for messages.BotResults: Instance of BotResults.
        """
        super().__init__()

        self.gallery = gallery
        self.query_id = query_id
        self.next_offset = next_offset
        self.switch_pm = switch_pm
        self.results = results
        self.cache_time = cache_time
        self.users = users

    def to_dict(self):
        return {
            '_': 'BotResults',
            'gallery': self.gallery,
            'query_id': self.query_id,
            'next_offset': self.next_offset,
            'switch_pm': None if self.switch_pm is None else self.switch_pm.to_dict(),
            'results': [] if self.results is None else [None if x is None else x.to_dict() for x in self.results],
            'cache_time': self.cache_time,
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'H\xa8|\x94',
            struct.pack('<I', (0 if self.gallery is None or self.gallery is False else 1) | (0 if self.next_offset is None or self.next_offset is False else 2) | (0 if self.switch_pm is None or self.switch_pm is False else 4)),
            struct.pack('<q', self.query_id),
            b'' if self.next_offset is None or self.next_offset is False else (TLObject.serialize_bytes(self.next_offset)),
            b'' if self.switch_pm is None or self.switch_pm is False else (bytes(self.switch_pm)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.results)),b''.join(bytes(x) for x in self.results),
            struct.pack('<i', self.cache_time),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _gallery = bool(flags & 1)
        _query_id = reader.read_long()
        if flags & 2:
            _next_offset = reader.tgread_string()
        else:
            _next_offset = None
        if flags & 4:
            _switch_pm = reader.tgread_object()
        else:
            _switch_pm = None
        reader.read_int()
        _results = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _results.append(_x)

        _cache_time = reader.read_int()
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return BotResults(query_id=_query_id, results=_results, cache_time=_cache_time, users=_users, gallery=_gallery, next_offset=_next_offset, switch_pm=_switch_pm)


class ChannelMessages(TLObject):
    CONSTRUCTOR_ID = 0x99262e37
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, pts, count, messages, chats, users):
        """
        :param int pts:
        :param int count:
        :param list[Message] messages:
        :param list[Chat] chats:
        :param list[User] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        super().__init__()

        self.pts = pts
        self.count = count
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            '_': 'ChannelMessages',
            'pts': self.pts,
            'count': self.count,
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'7.&\x99',
            b'\0\0\0\0',
            struct.pack('<i', self.pts),
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _pts = reader.read_int()
        _count = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return ChannelMessages(pts=_pts, count=_count, messages=_messages, chats=_chats, users=_users)


class ChatFull(TLObject):
    CONSTRUCTOR_ID = 0xe5d7d19c
    SUBCLASS_OF_ID = 0x225a5109

    def __init__(self, full_chat, chats, users):
        """
        :param ChatFull full_chat:
        :param list[Chat] chats:
        :param list[User] users:

        Constructor for messages.ChatFull: Instance of ChatFull.
        """
        super().__init__()

        self.full_chat = full_chat
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            '_': 'ChatFull',
            'full_chat': None if self.full_chat is None else self.full_chat.to_dict(),
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\x9c\xd1\xd7\xe5',
            bytes(self.full_chat),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        _full_chat = reader.tgread_object()
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return ChatFull(full_chat=_full_chat, chats=_chats, users=_users)


class Chats(TLObject):
    CONSTRUCTOR_ID = 0x64ff9fd5
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, chats):
        """
        :param list[Chat] chats:

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()

        self.chats = chats

    def to_dict(self):
        return {
            '_': 'Chats',
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]
        }

    def __bytes__(self):
        return b''.join((
            b'\xd5\x9f\xffd',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        return Chats(chats=_chats)


class ChatsSlice(TLObject):
    CONSTRUCTOR_ID = 0x9cd81144
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, count, chats):
        """
        :param int count:
        :param list[Chat] chats:

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        super().__init__()

        self.count = count
        self.chats = chats

    def to_dict(self):
        return {
            '_': 'ChatsSlice',
            'count': self.count,
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]
        }

    def __bytes__(self):
        return b''.join((
            b'D\x11\xd8\x9c',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
        ))

    @staticmethod
    def from_reader(reader):
        _count = reader.read_int()
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        return ChatsSlice(count=_count, chats=_chats)


class DhConfig(TLObject):
    CONSTRUCTOR_ID = 0x2c221edd
    SUBCLASS_OF_ID = 0xe488ed8b

    def __init__(self, g, p, version, random):
        """
        :param int g:
        :param bytes p:
        :param int version:
        :param bytes random:

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()

        self.g = g
        self.p = p
        self.version = version
        self.random = random

    def to_dict(self):
        return {
            '_': 'DhConfig',
            'g': self.g,
            'p': self.p,
            'version': self.version,
            'random': self.random
        }

    def __bytes__(self):
        return b''.join((
            b'\xdd\x1e",',
            struct.pack('<i', self.g),
            TLObject.serialize_bytes(self.p),
            struct.pack('<i', self.version),
            TLObject.serialize_bytes(self.random),
        ))

    @staticmethod
    def from_reader(reader):
        _g = reader.read_int()
        _p = reader.tgread_bytes()
        _version = reader.read_int()
        _random = reader.tgread_bytes()
        return DhConfig(g=_g, p=_p, version=_version, random=_random)


class DhConfigNotModified(TLObject):
    CONSTRUCTOR_ID = 0xc0e24635
    SUBCLASS_OF_ID = 0xe488ed8b

    def __init__(self, random):
        """
        :param bytes random:

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        super().__init__()

        self.random = random

    def to_dict(self):
        return {
            '_': 'DhConfigNotModified',
            'random': self.random
        }

    def __bytes__(self):
        return b''.join((
            b'5F\xe2\xc0',
            TLObject.serialize_bytes(self.random),
        ))

    @staticmethod
    def from_reader(reader):
        _random = reader.tgread_bytes()
        return DhConfigNotModified(random=_random)


class Dialogs(TLObject):
    CONSTRUCTOR_ID = 0x15ba6c40
    SUBCLASS_OF_ID = 0xe1b52ee

    def __init__(self, dialogs, messages, chats, users):
        """
        :param list[Dialog] dialogs:
        :param list[Message] messages:
        :param list[Chat] chats:
        :param list[User] users:

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()

        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            '_': 'Dialogs',
            'dialogs': [] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs],
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'@l\xba\x15',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dialogs)),b''.join(bytes(x) for x in self.dialogs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _dialogs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dialogs.append(_x)

        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return Dialogs(dialogs=_dialogs, messages=_messages, chats=_chats, users=_users)


class DialogsSlice(TLObject):
    CONSTRUCTOR_ID = 0x71e094f3
    SUBCLASS_OF_ID = 0xe1b52ee

    def __init__(self, count, dialogs, messages, chats, users):
        """
        :param int count:
        :param list[Dialog] dialogs:
        :param list[Message] messages:
        :param list[Chat] chats:
        :param list[User] users:

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice.
        """
        super().__init__()

        self.count = count
        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            '_': 'DialogsSlice',
            'count': self.count,
            'dialogs': [] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs],
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\xf3\x94\xe0q',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dialogs)),b''.join(bytes(x) for x in self.dialogs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        _count = reader.read_int()
        reader.read_int()
        _dialogs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dialogs.append(_x)

        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return DialogsSlice(count=_count, dialogs=_dialogs, messages=_messages, chats=_chats, users=_users)


class FavedStickers(TLObject):
    CONSTRUCTOR_ID = 0xf37f2f16
    SUBCLASS_OF_ID = 0x8e736fb9

    def __init__(self, hash, packs, stickers):
        """
        :param int hash:
        :param list[StickerPack] packs:
        :param list[Document] stickers:

        Constructor for messages.FavedStickers: Instance of either FavedStickersNotModified, FavedStickers.
        """
        super().__init__()

        self.hash = hash
        self.packs = packs
        self.stickers = stickers

    def to_dict(self):
        return {
            '_': 'FavedStickers',
            'hash': self.hash,
            'packs': [] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs],
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]
        }

    def __bytes__(self):
        return b''.join((
            b'\x16/\x7f\xf3',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.packs)),b''.join(bytes(x) for x in self.packs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _packs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _packs.append(_x)

        reader.read_int()
        _stickers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _stickers.append(_x)

        return FavedStickers(hash=_hash, packs=_packs, stickers=_stickers)


class FavedStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0x9e8fa6d3
    SUBCLASS_OF_ID = 0x8e736fb9

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'FavedStickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd3\xa6\x8f\x9e',
        ))

    @staticmethod
    def from_reader(reader):
        return FavedStickersNotModified()


class FeaturedStickers(TLObject):
    CONSTRUCTOR_ID = 0xf89d88e5
    SUBCLASS_OF_ID = 0x2614b722

    def __init__(self, hash, sets, unread):
        """
        :param int hash:
        :param list[StickerSetCovered] sets:
        :param list[int] unread:

        Constructor for messages.FeaturedStickers: Instance of either FeaturedStickersNotModified, FeaturedStickers.
        """
        super().__init__()

        self.hash = hash
        self.sets = sets
        self.unread = unread

    def to_dict(self):
        return {
            '_': 'FeaturedStickers',
            'hash': self.hash,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets],
            'unread': [] if self.unread is None else self.unread[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\xe5\x88\x9d\xf8',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.unread)),b''.join(struct.pack('<q', x) for x in self.unread),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        reader.read_int()
        _unread = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _unread.append(_x)

        return FeaturedStickers(hash=_hash, sets=_sets, unread=_unread)


class FeaturedStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0x4ede3cf
    SUBCLASS_OF_ID = 0x2614b722

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'FeaturedStickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\xe3\xed\x04',
        ))

    @staticmethod
    def from_reader(reader):
        return FeaturedStickersNotModified()


class FoundGifs(TLObject):
    CONSTRUCTOR_ID = 0x450a1c0a
    SUBCLASS_OF_ID = 0xe799ea7

    def __init__(self, next_offset, results):
        """
        :param int next_offset:
        :param list[FoundGif] results:

        Constructor for messages.FoundGifs: Instance of FoundGifs.
        """
        super().__init__()

        self.next_offset = next_offset
        self.results = results

    def to_dict(self):
        return {
            '_': 'FoundGifs',
            'next_offset': self.next_offset,
            'results': [] if self.results is None else [None if x is None else x.to_dict() for x in self.results]
        }

    def __bytes__(self):
        return b''.join((
            b'\n\x1c\nE',
            struct.pack('<i', self.next_offset),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.results)),b''.join(bytes(x) for x in self.results),
        ))

    @staticmethod
    def from_reader(reader):
        _next_offset = reader.read_int()
        reader.read_int()
        _results = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _results.append(_x)

        return FoundGifs(next_offset=_next_offset, results=_results)


class HighScores(TLObject):
    CONSTRUCTOR_ID = 0x9a3bfd99
    SUBCLASS_OF_ID = 0x6ccd95fd

    def __init__(self, scores, users):
        """
        :param list[HighScore] scores:
        :param list[User] users:

        Constructor for messages.HighScores: Instance of HighScores.
        """
        super().__init__()

        self.scores = scores
        self.users = users

    def to_dict(self):
        return {
            '_': 'HighScores',
            'scores': [] if self.scores is None else [None if x is None else x.to_dict() for x in self.scores],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\x99\xfd;\x9a',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.scores)),b''.join(bytes(x) for x in self.scores),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _scores = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _scores.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return HighScores(scores=_scores, users=_users)


class MessageEditData(TLObject):
    CONSTRUCTOR_ID = 0x26b5dde6
    SUBCLASS_OF_ID = 0xfb47949d

    def __init__(self, caption=None):
        """
        :param bool | None caption:

        Constructor for messages.MessageEditData: Instance of MessageEditData.
        """
        super().__init__()

        self.caption = caption

    def to_dict(self):
        return {
            '_': 'MessageEditData',
            'caption': self.caption
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6\xdd\xb5&',
            struct.pack('<I', (0 if self.caption is None or self.caption is False else 1)),
        ))

    @staticmethod
    def from_reader(reader):
        flags = reader.read_int()

        _caption = bool(flags & 1)
        return MessageEditData(caption=_caption)


class Messages(TLObject):
    CONSTRUCTOR_ID = 0x8c718e87
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, messages, chats, users):
        """
        :param list[Message] messages:
        :param list[Chat] chats:
        :param list[User] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        super().__init__()

        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            '_': 'Messages',
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\x87\x8eq\x8c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return Messages(messages=_messages, chats=_chats, users=_users)


class MessagesNotModified(TLObject):
    CONSTRUCTOR_ID = 0x74535f21
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, count):
        """
        :param int count:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        super().__init__()

        self.count = count

    def to_dict(self):
        return {
            '_': 'MessagesNotModified',
            'count': self.count
        }

    def __bytes__(self):
        return b''.join((
            b'!_St',
            struct.pack('<i', self.count),
        ))

    @staticmethod
    def from_reader(reader):
        _count = reader.read_int()
        return MessagesNotModified(count=_count)


class MessagesSlice(TLObject):
    CONSTRUCTOR_ID = 0xb446ae3
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, count, messages, chats, users):
        """
        :param int count:
        :param list[Message] messages:
        :param list[Chat] chats:
        :param list[User] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        super().__init__()

        self.count = count
        self.messages = messages
        self.chats = chats
        self.users = users

    def to_dict(self):
        return {
            '_': 'MessagesSlice',
            'count': self.count,
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\xe3jD\x0b',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @staticmethod
    def from_reader(reader):
        _count = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return MessagesSlice(count=_count, messages=_messages, chats=_chats, users=_users)


class PeerDialogs(TLObject):
    CONSTRUCTOR_ID = 0x3371c354
    SUBCLASS_OF_ID = 0x3ac70132

    def __init__(self, dialogs, messages, chats, users, state):
        """
        :param list[Dialog] dialogs:
        :param list[Message] messages:
        :param list[Chat] chats:
        :param list[User] users:
        :param updates.State state:

        Constructor for messages.PeerDialogs: Instance of PeerDialogs.
        """
        super().__init__()

        self.dialogs = dialogs
        self.messages = messages
        self.chats = chats
        self.users = users
        self.state = state

    def to_dict(self):
        return {
            '_': 'PeerDialogs',
            'dialogs': [] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs],
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'state': None if self.state is None else self.state.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'T\xc3q3',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dialogs)),b''.join(bytes(x) for x in self.dialogs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            bytes(self.state),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _dialogs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dialogs.append(_x)

        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        _state = reader.tgread_object()
        return PeerDialogs(dialogs=_dialogs, messages=_messages, chats=_chats, users=_users, state=_state)


class RecentStickers(TLObject):
    CONSTRUCTOR_ID = 0x5ce20970
    SUBCLASS_OF_ID = 0xf76f8683

    def __init__(self, hash, stickers):
        """
        :param int hash:
        :param list[Document] stickers:

        Constructor for messages.RecentStickers: Instance of either RecentStickersNotModified, RecentStickers.
        """
        super().__init__()

        self.hash = hash
        self.stickers = stickers

    def to_dict(self):
        return {
            '_': 'RecentStickers',
            'hash': self.hash,
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]
        }

    def __bytes__(self):
        return b''.join((
            b'p\t\xe2\\',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _stickers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _stickers.append(_x)

        return RecentStickers(hash=_hash, stickers=_stickers)


class RecentStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0xb17f890
    SUBCLASS_OF_ID = 0xf76f8683

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'RecentStickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\x90\xf8\x17\x0b',
        ))

    @staticmethod
    def from_reader(reader):
        return RecentStickersNotModified()


class SavedGifs(TLObject):
    CONSTRUCTOR_ID = 0x2e0709a5
    SUBCLASS_OF_ID = 0xa68b61f5

    def __init__(self, hash, gifs):
        """
        :param int hash:
        :param list[Document] gifs:

        Constructor for messages.SavedGifs: Instance of either SavedGifsNotModified, SavedGifs.
        """
        super().__init__()

        self.hash = hash
        self.gifs = gifs

    def to_dict(self):
        return {
            '_': 'SavedGifs',
            'hash': self.hash,
            'gifs': [] if self.gifs is None else [None if x is None else x.to_dict() for x in self.gifs]
        }

    def __bytes__(self):
        return b''.join((
            b'\xa5\t\x07.',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.gifs)),b''.join(bytes(x) for x in self.gifs),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.read_int()
        reader.read_int()
        _gifs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _gifs.append(_x)

        return SavedGifs(hash=_hash, gifs=_gifs)


class SavedGifsNotModified(TLObject):
    CONSTRUCTOR_ID = 0xe8025ca2
    SUBCLASS_OF_ID = 0xa68b61f5

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'SavedGifsNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\xa2\\\x02\xe8',
        ))

    @staticmethod
    def from_reader(reader):
        return SavedGifsNotModified()


class SentEncryptedFile(TLObject):
    CONSTRUCTOR_ID = 0x9493ff32
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, date, file):
        """
        :param datetime.datetime | None date:
        :param EncryptedFile file:

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()

        self.date = date
        self.file = file

    def to_dict(self):
        return {
            '_': 'SentEncryptedFile',
            'date': self.date,
            'file': None if self.file is None else self.file.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'2\xff\x93\x94',
            TLObject.serialize_datetime(self.date),
            bytes(self.file),
        ))

    @staticmethod
    def from_reader(reader):
        _date = reader.tgread_date()
        _file = reader.tgread_object()
        return SentEncryptedFile(date=_date, file=_file)


class SentEncryptedMessage(TLObject):
    CONSTRUCTOR_ID = 0x560f8935
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, date):
        """
        :param datetime.datetime | None date:

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        super().__init__()

        self.date = date

    def to_dict(self):
        return {
            '_': 'SentEncryptedMessage',
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'5\x89\x0fV',
            TLObject.serialize_datetime(self.date),
        ))

    @staticmethod
    def from_reader(reader):
        _date = reader.tgread_date()
        return SentEncryptedMessage(date=_date)


class StickerSet(TLObject):
    CONSTRUCTOR_ID = 0xb60a24a6
    SUBCLASS_OF_ID = 0x9b704a5a

    def __init__(self, set, packs, documents):
        """
        :param StickerSet set:
        :param list[StickerPack] packs:
        :param list[Document] documents:

        Constructor for messages.StickerSet: Instance of StickerSet.
        """
        super().__init__()

        self.set = set
        self.packs = packs
        self.documents = documents

    def to_dict(self):
        return {
            '_': 'StickerSet',
            'set': None if self.set is None else self.set.to_dict(),
            'packs': [] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs],
            'documents': [] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]
        }

    def __bytes__(self):
        return b''.join((
            b'\xa6$\n\xb6',
            bytes(self.set),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.packs)),b''.join(bytes(x) for x in self.packs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(bytes(x) for x in self.documents),
        ))

    @staticmethod
    def from_reader(reader):
        _set = reader.tgread_object()
        reader.read_int()
        _packs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _packs.append(_x)

        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _documents.append(_x)

        return StickerSet(set=_set, packs=_packs, documents=_documents)


class StickerSetInstallResultArchive(TLObject):
    CONSTRUCTOR_ID = 0x35e410a8
    SUBCLASS_OF_ID = 0x67cb3fe8

    def __init__(self, sets):
        """
        :param list[StickerSetCovered] sets:

        Constructor for messages.StickerSetInstallResult: Instance of either StickerSetInstallResultSuccess, StickerSetInstallResultArchive.
        """
        super().__init__()

        self.sets = sets

    def to_dict(self):
        return {
            '_': 'StickerSetInstallResultArchive',
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]
        }

    def __bytes__(self):
        return b''.join((
            b'\xa8\x10\xe45',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @staticmethod
    def from_reader(reader):
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return StickerSetInstallResultArchive(sets=_sets)


class StickerSetInstallResultSuccess(TLObject):
    CONSTRUCTOR_ID = 0x38641628
    SUBCLASS_OF_ID = 0x67cb3fe8

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'StickerSetInstallResultSuccess'
        }

    def __bytes__(self):
        return b''.join((
            b'(\x16d8',
        ))

    @staticmethod
    def from_reader(reader):
        return StickerSetInstallResultSuccess()


class Stickers(TLObject):
    CONSTRUCTOR_ID = 0x8a8ecd32
    SUBCLASS_OF_ID = 0xd73bb9de

    def __init__(self, hash, stickers):
        """
        :param str hash:
        :param list[Document] stickers:

        Constructor for messages.Stickers: Instance of either StickersNotModified, Stickers.
        """
        super().__init__()

        self.hash = hash
        self.stickers = stickers

    def to_dict(self):
        return {
            '_': 'Stickers',
            'hash': self.hash,
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]
        }

    def __bytes__(self):
        return b''.join((
            b'2\xcd\x8e\x8a',
            TLObject.serialize_bytes(self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers),
        ))

    @staticmethod
    def from_reader(reader):
        _hash = reader.tgread_string()
        reader.read_int()
        _stickers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _stickers.append(_x)

        return Stickers(hash=_hash, stickers=_stickers)


class StickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0xf1749a22
    SUBCLASS_OF_ID = 0xd73bb9de

    def __init__(self):
        super().__init__()

    def to_dict(self):
        return {
            '_': 'StickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'"\x9at\xf1',
        ))

    @staticmethod
    def from_reader(reader):
        return StickersNotModified()
